import{createHash}from"node:crypto";import WebSocket from"ws";const LIVENESS_PING_INTERVAL_MS=15e3,LIVENESS_CHECK_INTERVAL_MS=5e3,LIVENESS_TIMEOUT_MS=6e4,RECONNECT_NOTIFICATION_TIMEOUT_MS=6e4,KIMI_BOT_TOKEN_HEADER="X-Kimi-Bot-Token",resolvePositiveDuration=(e,t)=>"number"!=typeof e||!Number.isFinite(e)||e<=0?t:e;export class JsonRpcWsClient{name;url;headers;token;logger;writeObsEvent;retry;onMessage;onReady;onClose;livenessPingIntervalMs;livenessCheckIntervalMs;livenessTimeoutMs;ws=null;ready=!1;closing=!1;backoffMs;attempts=0;authFailed=!1;reconnectTimer=null;livenessPingTimer=null;livenessCheckTimer=null;reconnectNotificationTimer=null;lastSeenAt=0;connectionSeq=0;currentConnectionId=null;constructor(e){this.name=e.name,this.url=e.url,this.headers={...e.headers??{}},this.token=e.token,this.logger=e.logger,this.writeObsEvent=e.writeObsEvent,this.retry=e.retry,this.onMessage=e.onMessage,this.onReady=e.onReady,this.onClose=e.onClose,this.livenessPingIntervalMs=resolvePositiveDuration(e.liveness?.pingIntervalMs,15e3),this.livenessCheckIntervalMs=resolvePositiveDuration(e.liveness?.checkIntervalMs,5e3),this.livenessTimeoutMs=resolvePositiveDuration(e.liveness?.timeoutMs,6e4),this.backoffMs=e.retry.baseMs}emitTransportEvent(e,t){this.writeObsEvent?.({component:"connector",domain:"transport",name:`transport.${t.name}`,severity:t.severity,hop:"bridge_ws",where:"JsonRpcWsClient",summary:t.summary,payload:{client:this.name,url:this.url,connectionId:e,...t.payload},error:t.error})}emitTransportMessageEvent(e,t,s){this.writeObsEvent&&this.writeObsEvent({component:"connector",domain:"transport",name:"transport.message",severity:"debug",hop:"bridge_ws",where:"JsonRpcWsClient",payload:{client:this.name,url:this.url,connectionId:e,direction:t,sizeBytes:Buffer.byteLength(s,"utf8"),payloadHash:createHash("sha256").update(s).digest("hex")}})}emitHeartbeatEvent(e){this.writeObsEvent?.({trace:"heartbeat",component:"connector",domain:"transport",name:`transport.heartbeat.${e.name}`,severity:e.severity??"debug",hop:e.hop,where:"JsonRpcWsClient",summary:e.summary,payload:{client:this.name,url:this.url,connectionId:this.currentConnectionId??void 0,...e.payload}})}sendRaw(e){if(!this.ws||this.ws.readyState!==WebSocket.OPEN)return!1;try{return this.ws.send(e),this.currentConnectionId&&this.emitTransportMessageEvent(this.currentConnectionId,"send",e),!0}catch(e){return this.logger.warn(`[${this.name}] send failed: ${String(e)}`),!1}}start(){this.closing=!1,this.authFailed=!1,this.connect()}stop(){if(this.closing=!0,this.authFailed=!1,this.ready=!1,this.stopLiveness(),this.stopReconnectNotificationTimer(),this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.ws)try{this.ws.close()}catch{}this.ws=null,this.currentConnectionId=null}isReady(){return this.ready}send(e){if(!this.ws||this.ws.readyState!==WebSocket.OPEN||!this.ready)return!1;try{const t=JSON.stringify(e);return this.sendRaw(t)}catch(e){return this.logger.warn(`[${this.name}] send failed: ${String(e)}`),!1}}connect(){if(this.closing)return;const e=`${this.name}-${this.connectionSeq+=1}`;this.currentConnectionId=e;const t=Date.now();let s=!1,n=!1;this.emitTransportEvent(e,{name:"connect_start",severity:"info"});const i={...this.headers};this.token&&(i["X-Kimi-Bot-Token"]=this.token),this.logger.info(`[${this.name}] connecting to ${this.url}`),this.ws=new WebSocket(this.url,{headers:i}),this.ws.on("open",()=>{this.ready=!0,s=!0,this.markSeen(),this.startLiveness(),this.backoffMs=this.retry.baseMs,this.attempts=0,this.logger.info(`[${this.name}] connected`),this.emitTransportEvent(e,{name:"connect_ok",severity:"info",payload:{durationMs:Date.now()-t}}),this.onReady?.()}),this.ws.on("message",t=>{this.markSeen();const s=t.toString();if(this.emitTransportMessageEvent(e,"recv",s),this.handleTextHeartbeat(s))return;let n;try{n=JSON.parse(s)}catch{return void this.logger.warn(`[${this.name}] invalid json payload`)}this.isReconnectNotification(n)?(this.logger.info(`[${this.name}] received reconnect notification, starting 1min timer`),this.startReconnectNotificationTimer()):this.stopReconnectNotificationTimer(),this.onMessage?.(n)}),this.ws.on("pong",()=>{this.markSeen(),this.emitHeartbeatEvent({name:"ws_frame_pong_recv",hop:"bridge_ws->plugin",summary:"ws frame pong recv",payload:{transport:"ws_frame",direction:"inbound"}})}),this.ws.on("close",(s,n)=>{this.ready=!1,this.stopLiveness();const i=n.toString();this.logger.warn(`[${this.name}] closed code=${s} reason=${i}`),this.emitTransportEvent(e,{name:"close",severity:"warn",payload:{closeCode:s,closeReason:i,durationMs:Date.now()-t}}),this.onClose?.(),4001!==s?this.scheduleReconnect(e):this.markAuthFailed("4001")}),this.ws.on("unexpected-response",(i,r)=>{const o=r.statusCode;if(401===o)return s||n||(n=!0,this.emitTransportEvent(e,{name:"connect_fail",severity:"error",payload:{httpStatus:401,durationMs:Date.now()-t},summary:"upgrade rejected (http 401)",error:{code:"HTTP_401",message:"auth failed (http 401)"}})),void this.markAuthFailed("http 401");s||n||(n=!0,this.emitTransportEvent(e,{name:"connect_fail",severity:"warn",payload:{httpStatus:"number"==typeof o?o:void 0,durationMs:Date.now()-t},summary:`unexpected http response status=${String(o??"unknown")}`,error:{code:"UNEXPECTED_HTTP_STATUS",message:"unexpected http response during websocket upgrade",httpStatus:o}})),this.logger.warn(`[${this.name}] unexpected http response status=${String(o??"unknown")}`),this.scheduleReconnect(e)}),this.ws.on("error",i=>{this.logger.warn(`[${this.name}] error: ${String(i)}`);const r=i instanceof Error?i.message:String(i);s||n||(n=!0,this.emitTransportEvent(e,{name:"connect_fail",severity:"warn",payload:{durationMs:Date.now()-t},summary:r,error:{code:"WS_ERROR",message:r}})),r.includes("401")&&this.markAuthFailed("http 401")})}markSeen(){this.lastSeenAt=Date.now()}startLiveness(){this.stopLiveness(),this.markSeen(),this.livenessPingTimer=setInterval(()=>{if(this.ws&&this.ws.readyState===WebSocket.OPEN)try{this.ws.send(JSON.stringify({type:"ping"})),this.emitHeartbeatEvent({name:"ws_frame_ping_sent",hop:"plugin->bridge_ws",summary:"ws frame ping sent",payload:{transport:"ws_frame",direction:"outbound"}})}catch(e){this.logger.warn(`[${this.name}] ping failed: ${String(e)}`)}},this.livenessPingIntervalMs),this.livenessPingTimer.unref?.(),this.livenessCheckTimer=setInterval(()=>{if(!this.ws||this.ws.readyState!==WebSocket.OPEN)return;const e=Date.now()-this.lastSeenAt;if(!(e<=this.livenessTimeoutMs)){this.emitHeartbeatEvent({name:"timeout",severity:"warn",hop:"bridge_ws",summary:"heartbeat timeout forcing reconnect",payload:{staleMs:e,timeoutMs:this.livenessTimeoutMs,action:"terminate_for_reconnect"}}),this.logger.warn(`[${this.name}] liveness timeout stale_ms=${e} forcing reconnect`),this.stopLiveness();try{this.ws.terminate()}catch{}}},this.livenessCheckIntervalMs),this.livenessCheckTimer.unref?.()}stopLiveness(){this.livenessPingTimer&&(clearInterval(this.livenessPingTimer),this.livenessPingTimer=null),this.livenessCheckTimer&&(clearInterval(this.livenessCheckTimer),this.livenessCheckTimer=null)}stopReconnectNotificationTimer(){this.reconnectNotificationTimer&&(clearTimeout(this.reconnectNotificationTimer),this.reconnectNotificationTimer=null)}startReconnectNotificationTimer(){this.stopReconnectNotificationTimer(),this.reconnectNotificationTimer=setTimeout(()=>{if(this.logger.warn(`[${this.name}] reconnect notification timeout (no non-pong message received within 1min), forcing reconnect`),this.ws)try{this.ws.terminate()}catch{}},6e4)}isReconnectNotification(e){if("object"!=typeof e||null===e)return!1;const t=e;return"2.0"===t.jsonrpc&&"_kimi.com/reconnect"===t.method}handleTextHeartbeat(e){const t=e.trim().toLowerCase();return"ping"===t?(this.emitHeartbeatEvent({name:"text_ping_recv",hop:"bridge_ws->plugin",summary:"text ping recv",payload:{transport:"text",direction:"inbound"}}),!this.ws||this.ws.readyState!==WebSocket.OPEN||(this.sendRaw("pong")&&this.emitHeartbeatEvent({name:"text_pong_sent",hop:"plugin->bridge_ws",summary:"text pong sent",payload:{transport:"text",direction:"outbound"}}),!0)):"pong"===t&&(this.emitHeartbeatEvent({name:"text_pong_recv",hop:"bridge_ws->plugin",summary:"text pong recv",payload:{transport:"text",direction:"inbound"}}),!0)}scheduleReconnect(e){if(this.stopReconnectNotificationTimer(),this.closing)return;if(this.authFailed)return;if(this.retry.maxAttempts>0&&this.attempts>=this.retry.maxAttempts)return this.logger.error(`[${this.name}] retry limit reached, giving up`),void this.emitTransportEvent(e,{name:"retry_exhausted",severity:"error",summary:"retry limit reached, giving up",payload:{attempt:this.attempts,maxAttempts:this.retry.maxAttempts}});const t=Math.min(this.backoffMs,this.retry.maxMs),s=this.attempts+1,n=Math.min(2*this.backoffMs,this.retry.maxMs);this.emitTransportEvent(e,{name:"reconnect_scheduled",severity:"info",payload:{reconnectDelayMs:t,attempt:s,nextBackoffMs:n}}),this.attempts=s,this.backoffMs=n,this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.reconnectTimer=setTimeout(()=>this.connect(),t),this.reconnectTimer.unref?.()}markAuthFailed(e){this.authFailed||(this.authFailed=!0,this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.logger.error(`[${this.name}] auth failed (${e}), will not retry`))}}