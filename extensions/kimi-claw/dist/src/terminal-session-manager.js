import{spawn}from"node:child_process";import{randomUUID}from"node:crypto";import{createRequire}from"node:module";import{asTrimmedNonEmptyString as asNonEmptyString}from"./utils/text.js";export const TERMINAL_SESSION_STATES={opening:"opening",running:"running",closing:"closing",closed:"closed"};export const TERMINAL_TIMEOUT_REASONS={idle:"idle_timeout",maxDuration:"max_duration_timeout"};const ALLOWED_STATE_TRANSITIONS={opening:["running","closing","closed"],running:["closing","closed"],closing:["closed"],closed:[]},isPositiveInteger=e=>"number"==typeof e&&Number.isInteger(e)&&e>0,assertPositiveInteger=(e,t)=>{if(!isPositiveInteger(e))throw new Error(`[terminal] ${t} must be a positive integer`)},toBuffer=e=>"string"==typeof e?Buffer.from(e,"utf8"):Buffer.from(e),chainEventHandler=(e,t)=>t?e?s=>{e(s),t(s)}:t:e,require=createRequire(import.meta.url);let cachedNodePty;const REQUIRE_PTY="1"===process.env.OPENCLAW_BRIDGE_SHELL_REQUIRE_PTY,getNodePty=()=>{if(cachedNodePty)return cachedNodePty;try{return cachedNodePty=require("node-pty"),cachedNodePty}catch(e){const t=e instanceof Error?e.message:String(e);throw new Error(`[terminal] failed to load node-pty: ${t} ${import.meta.url}`)}},createPipeTerminalProcess=e=>{const t=spawn(e.shell,[],{cwd:e.cwd,env:process.env,stdio:["pipe","pipe","pipe"]});let s=!1;const i=t=>{s||(s=!0,e.onExit(t))};return t.stdout.on("data",t=>{e.onData(Buffer.isBuffer(t)?t:Buffer.from(t))}),t.stderr.on("data",t=>{e.onData(Buffer.isBuffer(t)?t:Buffer.from(t))}),t.once("error",e=>{i({code:null,signal:null,error:e})}),t.once("exit",(e,t)=>{i({code:"number"==typeof e?e:null,signal:t?String(t):null})}),{write:e=>{t.stdin.destroyed||t.stdin.write(e)},resize:(e,t)=>{},close:()=>{t.killed||t.kill()}}},createPtyTerminalProcess=e=>{const t=getNodePty(),s={...process.env,TERM:"ansi"};let i,r,n;try{i=t.spawn(e.shell,[],{name:s.TERM,cwd:e.cwd,env:s,cols:e.cols,rows:e.rows})}catch(e){const t=e instanceof Error?e.message:String(e);throw new Error(`[terminal] failed to start pty process: ${t}`)}let o=!1;const a=t=>{o||(o=!0,r?.dispose?.(),n?.dispose?.(),e.onExit(t))};return r=i.onData(t=>{e.onData(Buffer.from(t,"utf8"))}),n=i.onExit(e=>{a({code:Number.isFinite(e.exitCode)?e.exitCode:null,signal:Number.isFinite(e.signal)?String(e.signal):null})}),{write:e=>{const t=e.toString("utf8");t&&i.write(t)},resize:(e,t)=>{i.resize(e,t)},close:()=>{try{i.kill()}catch(e){a({code:null,signal:null,...e instanceof Error?{error:e}:{}})}}}},createDefaultTerminalProcess=e=>{try{return createPtyTerminalProcess(e)}catch(t){if(REQUIRE_PTY)throw t;const s=t instanceof Error?t.message:String(t);return process.emitWarning(`[terminal] node-pty unavailable, falling back to pipe mode: ${s}`),createPipeTerminalProcess(e)}};export class TerminalNotFoundError extends Error{terminalId;constructor(e){super(`terminal not found: ${e}`),this.name="TerminalNotFoundError",this.terminalId=e}}export class TerminalClosedError extends Error{terminalId;state;constructor(e,t){super(`terminal is not writable in state=${t}: ${e}`),this.name="TerminalClosedError",this.terminalId=e,this.state=t}}export class TerminalTimeoutError extends TerminalClosedError{reason;constructor(e,t,s){super(e,t),this.name="TerminalTimeoutError",this.reason=s}}export class TerminalSessionManager{defaultShell;defaultCwd;idleTimeoutMs;maxDurationMs;now;setTimer;clearTimer;createTerminalId;createProcess;onOutput;onExit;onStateChange;sessions=new Map;constructor(e){const t=asNonEmptyString(e.defaultShell);if(!t)throw new Error("[terminal] defaultShell must be a non-empty string");this.defaultShell=t,this.defaultCwd=asNonEmptyString(e.defaultCwd)??process.cwd(),void 0!==e.idleTimeoutMs&&assertPositiveInteger(e.idleTimeoutMs,"idleTimeoutMs"),void 0!==e.maxDurationMs&&assertPositiveInteger(e.maxDurationMs,"maxDurationMs"),this.idleTimeoutMs=e.idleTimeoutMs,this.maxDurationMs=e.maxDurationMs,this.now=e.now??(()=>Date.now()),this.setTimer=e.setTimer??((e,t)=>setTimeout(e,t)),this.clearTimer=e.clearTimer??(e=>clearTimeout(e)),this.createTerminalId=e.createTerminalId??(()=>`term_${randomUUID()}`),this.createProcess=e.createProcess??createDefaultTerminalProcess,this.onOutput=e.onOutput,this.onExit=e.onExit,this.onStateChange=e.onStateChange}addListeners(e){this.onOutput=chainEventHandler(this.onOutput,e.onOutput),this.onExit=chainEventHandler(this.onExit,e.onExit),this.onStateChange=chainEventHandler(this.onStateChange,e.onStateChange)}openSession(e){const t=asNonEmptyString(e.sessionId);if(!t)throw new Error("[terminal] sessionId must be a non-empty string");assertPositiveInteger(e.cols,"cols"),assertPositiveInteger(e.rows,"rows");const s=asNonEmptyString(e.shell)??this.defaultShell,i=asNonEmptyString(e.cwd)??this.defaultCwd,r=this.now(),n=asNonEmptyString(e.terminalId),o=n&&!this.sessions.has(n)?n:this.allocateTerminalId(),a={terminalId:o,sessionId:t,shell:s,cwd:i,startedAt:r,lastActiveAt:r,cols:e.cols,rows:e.rows,state:TERMINAL_SESSION_STATES.opening,nextSeq:1};this.sessions.set(o,a);try{a.process=this.createProcess({shell:s,cwd:i,cols:e.cols,rows:e.rows,onData:e=>this.handleProcessData(o,e),onExit:e=>this.handleProcessExit(o,e)}),this.transitionState(a,TERMINAL_SESSION_STATES.running),this.scheduleSessionTimers(a)}catch(e){throw this.clearSessionTimers(a),this.transitionState(a,TERMINAL_SESSION_STATES.closed),this.sessions.delete(o),e}return this.snapshot(a)}writeToSession(e,t){const s=this.requireSession(e);this.assertSessionRunning(s),s.process?.write(toBuffer(t)),this.markSessionActivity(s)}touchSession(e){const t=this.requireSession(e);return this.assertSessionRunning(t),this.markSessionActivity(t),this.snapshot(t)}resizeSession(e,t,s){assertPositiveInteger(t,"cols"),assertPositiveInteger(s,"rows");const i=this.requireSession(e);this.assertSessionRunning(i),i.cols=t,i.rows=s,this.markSessionActivity(i),i.process?.resize(t,s)}closeSession(e,t){const s=this.requireSession(e);return t?.reason&&!s.timeoutReason&&(s.timeoutReason=t.reason),s.state===TERMINAL_SESSION_STATES.closed?(this.clearSessionTimers(s),this.snapshot(s)):(this.clearSessionTimers(s),s.state!==TERMINAL_SESSION_STATES.closing&&(this.transitionState(s,TERMINAL_SESSION_STATES.closing),s.process?.close()),s.lastActiveAt=this.now(),this.snapshot(s))}getSession(e){const t=this.sessions.get(e);return t?this.snapshot(t):void 0}listSessions(){return[...this.sessions.values()].map(e=>this.snapshot(e))}allocateTerminalId(){let e=this.createTerminalId().trim();for(;!e||this.sessions.has(e);)e=this.createTerminalId().trim();return e}requireSession(e){const t=e.trim(),s=t?this.sessions.get(t):void 0;if(!s)throw new TerminalNotFoundError(e);return s}assertSessionRunning(e){if(e.state!==TERMINAL_SESSION_STATES.running){if(e.timeoutReason)throw new TerminalTimeoutError(e.terminalId,e.state,e.timeoutReason);throw new TerminalClosedError(e.terminalId,e.state)}}transitionState(e,t){const s=e.state;if(s!==t){if(!(ALLOWED_STATE_TRANSITIONS[s]??[]).includes(t))throw new Error(`[terminal] invalid state transition ${s} -> ${t} (${e.terminalId})`);e.state=t,this.onStateChange?.({terminalId:e.terminalId,sessionId:e.sessionId,from:s,to:t,at:this.now()})}}handleProcessData(e,t){const s=this.sessions.get(e);if(!s||s.state===TERMINAL_SESSION_STATES.closed)return;this.markSessionActivity(s);const i=s.nextSeq;s.nextSeq+=1,this.onOutput?.({terminalId:e,sessionId:s.sessionId,data:t,seq:i})}handleProcessExit(e,t){const s=this.sessions.get(e);s&&(this.clearSessionTimers(s),s.state!==TERMINAL_SESSION_STATES.closed&&(s.state!==TERMINAL_SESSION_STATES.closing&&this.transitionState(s,TERMINAL_SESSION_STATES.closing),this.transitionState(s,TERMINAL_SESSION_STATES.closed)),s.lastActiveAt=this.now(),this.onExit?.({terminalId:s.terminalId,sessionId:s.sessionId,code:t.code,signal:t.signal,...t.error?{error:t.error}:{},...s.timeoutReason?{reason:s.timeoutReason}:{}}))}markSessionActivity(e){e.lastActiveAt=this.now(),e.state===TERMINAL_SESSION_STATES.running&&this.refreshIdleTimer(e)}scheduleSessionTimers(e){e.state===TERMINAL_SESSION_STATES.running&&(this.refreshIdleTimer(e),this.ensureMaxDurationTimer(e))}refreshIdleTimer(e){e.idleTimer&&(this.clearTimer(e.idleTimer),e.idleTimer=void 0),void 0!==this.idleTimeoutMs&&(e.idleTimer=this.setTimer(()=>this.handleSessionTimeout(e.terminalId,TERMINAL_TIMEOUT_REASONS.idle),this.idleTimeoutMs),e.idleTimer.unref?.())}ensureMaxDurationTimer(e){if(e.maxDurationTimer||void 0===this.maxDurationMs)return;const t=Math.max(0,this.now()-e.startedAt),s=this.maxDurationMs-t;s<=0?this.handleSessionTimeout(e.terminalId,TERMINAL_TIMEOUT_REASONS.maxDuration):(e.maxDurationTimer=this.setTimer(()=>this.handleSessionTimeout(e.terminalId,TERMINAL_TIMEOUT_REASONS.maxDuration),s),e.maxDurationTimer.unref?.())}clearSessionTimers(e){e.idleTimer&&(this.clearTimer(e.idleTimer),e.idleTimer=void 0),e.maxDurationTimer&&(this.clearTimer(e.maxDurationTimer),e.maxDurationTimer=void 0)}handleSessionTimeout(e,t){const s=this.sessions.get(e);s&&s.state===TERMINAL_SESSION_STATES.running&&this.closeSession(e,{reason:t})}snapshot(e){return{terminalId:e.terminalId,sessionId:e.sessionId,shell:e.shell,cwd:e.cwd,startedAt:e.startedAt,lastActiveAt:e.lastActiveAt,cols:e.cols,rows:e.rows,state:e.state}}}