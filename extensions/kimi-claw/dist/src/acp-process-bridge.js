import{spawn}from"node:child_process";const DEFAULT_MAX_BUFFERED_MESSAGES=256,truncate=(t,e)=>t.length<=e?t:`${t.slice(0,e)}...`;export class AcpProcessBridge{name;command;args;logger;retry;onMessage;onReady;onClose;maxBufferedMessages;spawnFn;child=null;ready=!1;closing=!1;backoffMs;attempts=0;reconnectTimer=null;stdoutBuffer="";stderrBuffer="";writeQueue=[];waitingDrain=!1;constructor(t){this.name=t.name,this.command=t.command,this.args=t.args,this.logger=t.logger,this.retry=t.retry,this.onMessage=t.onMessage,this.onReady=t.onReady,this.onClose=t.onClose,this.maxBufferedMessages=t.maxBufferedMessages??256,this.spawnFn=t.spawnFn??spawn,this.backoffMs=t.retry.baseMs}start(){this.closing=!1,this.connect()}stop(){if(this.closing=!0,this.ready=!1,this.stdoutBuffer="",this.stderrBuffer="",this.writeQueue=[],this.waitingDrain=!1,this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),!this.child)return;const t=this.child;this.child=null;try{t.kill("SIGTERM")}catch{}}isReady(){return this.ready}send(t){let e="";try{e=`${JSON.stringify(t)}\n`}catch(t){return this.logger.warn(`[${this.name}] failed to serialize ACP message: ${String(t)}`),!1}return this.ready&&this.child&&!this.child.stdin.destroyed?(this.writeDirect(e)||this.enqueue(e),!0):(this.enqueue(e),!0)}connect(){if(this.closing)return;let t;this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null);try{t=this.spawnFn(this.command,this.args,{stdio:["pipe","pipe","pipe"]})}catch(t){return this.logger.error(`[${this.name}] spawn failed: ${String(t)}`),void this.scheduleReconnect()}this.child=t,this.ready=!0,this.stdoutBuffer="",this.stderrBuffer="",this.backoffMs=this.retry.baseMs,this.attempts=0,this.logger.info(`[${this.name}] spawned command="${this.command}" args="${this.args.join(" ")}"`),this.onReady?.(),t.stdout.on("data",t=>{this.handleStdout(t.toString("utf-8"))}),t.stderr.on("data",t=>{this.handleStderr(t.toString("utf-8"))}),t.on("error",t=>{this.logger.warn(`[${this.name}] process error: ${String(t)}`)}),t.on("close",(e,s)=>{this.child===t&&(this.ready=!1,this.child=null,this.waitingDrain=!1,this.onClose?.(),this.logger.warn(`[${this.name}] exited code=${String(e)} signal=${String(s)}`),this.scheduleReconnect())}),this.flushQueue()}handleStdout(t){for(this.stdoutBuffer+=t;;){const t=this.stdoutBuffer.indexOf("\n");if(t<0)return;const e=this.stdoutBuffer.slice(0,t);this.stdoutBuffer=this.stdoutBuffer.slice(t+1);const s=e.trim();if(s)try{const t=JSON.parse(s);this.onMessage?.(t)}catch{this.logger.warn(`[${this.name}] invalid ACP stdout json: ${truncate(s,160)}`)}}}handleStderr(t){for(this.stderrBuffer+=t;;){const t=this.stderrBuffer.indexOf("\n");if(t<0)return;const e=this.stderrBuffer.slice(0,t);this.stderrBuffer=this.stderrBuffer.slice(t+1);const s=e.trim();s&&this.logger.debug?.(`[${this.name}:stderr] ${s}`)}}enqueue(t){this.writeQueue.length>=this.maxBufferedMessages&&(this.writeQueue.shift(),this.logger.warn(`[${this.name}] outbound queue full (${this.maxBufferedMessages}), dropping oldest`)),this.writeQueue.push(t)}flushQueue(){if(this.child&&!this.child.stdin.destroyed)for(;this.writeQueue.length>0;){const t=this.writeQueue[0];if(!this.writeDirect(t))return;this.writeQueue.shift()}}writeDirect(t){const e=this.child;if(!e||e.stdin.destroyed)return!1;try{return!!e.stdin.write(t,"utf-8")||(this.waitingDrain||(this.waitingDrain=!0,e.stdin.once("drain",()=>{this.waitingDrain=!1,this.flushQueue()})),!1)}catch(t){return this.logger.warn(`[${this.name}] stdin write failed: ${String(t)}`),!1}}scheduleReconnect(){if(this.closing)return;if(this.retry.maxAttempts>0&&this.attempts>=this.retry.maxAttempts)return void this.logger.error(`[${this.name}] retry limit reached, giving up`);const t=Math.min(this.backoffMs,this.retry.maxMs);this.attempts+=1,this.backoffMs=Math.min(2*this.backoffMs,this.retry.maxMs),this.reconnectTimer=setTimeout(()=>this.connect(),t),this.reconnectTimer.unref?.()}}