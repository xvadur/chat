import{createHash}from"node:crypto";import WebSocket from"ws";const CONNECT_REQUEST_ID="connect",LIVENESS_PING_INTERVAL_MS=15e3,LIVENESS_CHECK_INTERVAL_MS=5e3,LIVENESS_TIMEOUT_MS=6e4,resolvePositiveDuration=(e,t)=>"number"!=typeof e||!Number.isFinite(e)||e<=0?t:e;export class HandshakeWsClient{name;url;headers;logger;writeObsEvent;obsHop;retry;livenessPingIntervalMs;livenessCheckIntervalMs;livenessTimeoutMs;buildConnect;onFrame;onReady;onClose;ws=null;ready=!1;closing=!1;backoffMs;attempts=0;connectTimer=null;reconnectTimer=null;connectSent=!1;connectNonce=null;livenessPingTimer=null;livenessCheckTimer=null;lastSeenAt=0;connectionSeq=0;lastReadyAt=0;currentConnectionId=null;constructor(e){this.name=e.name,this.url=e.url,this.headers={...e.headers??{}},this.logger=e.logger,this.writeObsEvent=e.writeObsEvent,this.obsHop=e.obsHop,this.retry=e.retry,this.livenessPingIntervalMs=resolvePositiveDuration(e.liveness?.pingIntervalMs,15e3),this.livenessCheckIntervalMs=resolvePositiveDuration(e.liveness?.checkIntervalMs,5e3),this.livenessTimeoutMs=resolvePositiveDuration(e.liveness?.timeoutMs,6e4),this.buildConnect=e.buildConnect,this.onFrame=e.onFrame,this.onReady=e.onReady,this.onClose=e.onClose,this.backoffMs=e.retry.baseMs}emitTransportEvent(e,t){this.writeObsEvent?.({component:"connector",domain:"transport",name:`transport.${t.name}`,severity:t.severity,hop:this.obsHop,where:"HandshakeWsClient",summary:t.summary,payload:{client:this.name,url:this.url,connectionId:e,...t.payload},error:t.error})}resolveObsHopBase(){return this.obsHop?.trim()||"gateway_ws"}resolveOutboundObsHop(){return`plugin->${this.resolveObsHopBase()}`}resolveInboundObsHop(){return`${this.resolveObsHopBase()}->plugin`}emitHandshakeEvent(e){this.writeObsEvent?.({component:"connector",domain:"transport",name:`transport.handshake.${e.name}`,severity:e.severity??"info",hop:this.obsHop,where:"HandshakeWsClient",summary:e.summary,payload:{client:this.name,url:this.url,connectionId:this.currentConnectionId??void 0,...e.payload},error:e.error})}emitHeartbeatEvent(e){this.writeObsEvent?.({trace:"heartbeat",component:"connector",domain:"transport",name:`transport.heartbeat.${e.name}`,severity:e.severity??"debug",hop:e.hop,where:"HandshakeWsClient",summary:e.summary,payload:{client:this.name,url:this.url,connectionId:this.currentConnectionId??void 0,...e.payload}})}emitTransportMessageEvent(e,t,n){this.writeObsEvent&&this.writeObsEvent({component:"connector",domain:"transport",name:"transport.message",severity:"debug",hop:this.obsHop,where:"HandshakeWsClient",payload:{client:this.name,url:this.url,connectionId:e,direction:t,sizeBytes:Buffer.byteLength(n,"utf8"),payloadHash:createHash("sha256").update(n).digest("hex")}})}sendRaw(e){if(!this.ws||this.ws.readyState!==WebSocket.OPEN)return!1;try{return this.ws.send(e),this.currentConnectionId&&this.emitTransportMessageEvent(this.currentConnectionId,"send",e),!0}catch(e){return this.logger.warn(`[${this.name}] send failed: ${String(e)}`),!1}}start(){this.closing=!1,this.connect()}stop(){if(this.closing=!0,this.ready=!1,this.stopLiveness(),this.connectTimer&&(clearTimeout(this.connectTimer),this.connectTimer=null),this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.ws)try{this.ws.close()}catch{}this.ws=null,this.currentConnectionId=null}isReady(){return this.ready}send(e){if(!this.ws||this.ws.readyState!==WebSocket.OPEN||!this.ready)return!1;try{const t=JSON.stringify(e);return this.sendRaw(t)}catch(e){return this.logger.warn(`[${this.name}] send failed: ${String(e)}`),!1}}connect(){if(this.closing)return;this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null);const e=`${this.name}-${this.connectionSeq+=1}`;this.currentConnectionId=e;const t=Date.now(),n={connectFailed:!1};this.logger.info(`[${this.name}] connecting to ${this.url}`),this.emitTransportEvent(e,{name:"connect_start",severity:"info"}),this.ws=new WebSocket(this.url,{headers:this.headers}),this.ws.on("open",()=>{this.markSeen(),this.startLiveness(),this.queueConnect()}),this.ws.on("message",s=>{this.markSeen();const i=s.toString();this.emitTransportMessageEvent(e,"recv",i),this.handleMessage({raw:i,connectionId:e,connectStartedAt:t,attempt:n})}),this.ws.on("pong",()=>{this.markSeen(),this.emitHeartbeatEvent({name:"ws_frame_pong_recv",hop:this.resolveInboundObsHop(),summary:"ws frame pong recv",payload:{transport:"ws_frame",direction:"inbound"}})}),this.ws.on("close",(n,s)=>{const i=this.ready;this.ready=!1,this.stopLiveness();const r=s.toString();this.logger.warn(`[${this.name}] closed code=${n} reason=${r}`),this.emitTransportEvent(e,{name:"close",severity:"warn",payload:{closeCode:n,closeReason:r,wasReady:i,durationMs:Date.now()-t,lastReadyAt:this.lastReadyAt?new Date(this.lastReadyAt).toISOString():void 0}}),this.onClose?.(),this.scheduleReconnect(e)}),this.ws.on("error",s=>{this.logger.warn(`[${this.name}] error: ${String(s)}`);const i=s instanceof Error?s.message:String(s);this.ready||n.connectFailed||(n.connectFailed=!0,this.emitTransportEvent(e,{name:"connect_fail",severity:"warn",summary:i,payload:{durationMs:Date.now()-t},error:{code:"WS_ERROR",message:i}}))})}markSeen(){this.lastSeenAt=Date.now()}startLiveness(){this.stopLiveness(),this.markSeen(),this.livenessPingTimer=setInterval(()=>{if(this.ws&&this.ws.readyState===WebSocket.OPEN)try{this.ws.ping(),this.emitHeartbeatEvent({name:"ws_frame_ping_sent",hop:this.resolveOutboundObsHop(),summary:"ws frame ping sent",payload:{transport:"ws_frame",direction:"outbound"}})}catch(e){this.logger.warn(`[${this.name}] ping failed: ${String(e)}`)}},this.livenessPingIntervalMs),this.livenessPingTimer.unref?.(),this.livenessCheckTimer=setInterval(()=>{if(!this.ws||this.ws.readyState!==WebSocket.OPEN)return;const e=Date.now()-this.lastSeenAt;if(!(e<=this.livenessTimeoutMs)){this.emitHeartbeatEvent({name:"timeout",severity:"warn",hop:this.resolveObsHopBase(),summary:"heartbeat timeout forcing reconnect",payload:{staleMs:e,timeoutMs:this.livenessTimeoutMs,action:"terminate_for_reconnect"}}),this.logger.warn(`[${this.name}] liveness timeout stale_ms=${e} forcing reconnect`),this.stopLiveness();try{this.ws.terminate()}catch{}}},this.livenessCheckIntervalMs),this.livenessCheckTimer.unref?.()}stopLiveness(){this.livenessPingTimer&&(clearInterval(this.livenessPingTimer),this.livenessPingTimer=null),this.livenessCheckTimer&&(clearInterval(this.livenessCheckTimer),this.livenessCheckTimer=null)}handleMessage(e){const t=e.raw;if(this.handleTextHeartbeat(t))return;let n=null;try{n=JSON.parse(t)}catch{return void this.logger.warn(`[${this.name}] invalid json payload`)}if(n&&"object"==typeof n){if("event"===n.type&&"connect.challenge"===n.event){const e=n.payload,t="string"==typeof e?.nonce?e.nonce:void 0;return this.emitHandshakeEvent({name:"challenge_recv",summary:"connect challenge received",payload:{noncePresent:!!t}}),t&&(this.connectNonce=t),void this.sendConnect("challenge")}"res"!==n.type||"connect"!==n.id?this.ready&&this.onFrame?.(n):this.handleHandshakeResponse({frame:n,connectionId:e.connectionId,connectStartedAt:e.connectStartedAt,attempt:e.attempt})}}handleTextHeartbeat(e){const t=e.trim().toLowerCase();return"ping"===t?(this.emitHeartbeatEvent({name:"text_ping_recv",hop:this.resolveInboundObsHop(),summary:"text ping recv",payload:{transport:"text",direction:"inbound"}}),!this.ws||this.ws.readyState!==WebSocket.OPEN||(this.sendRaw("pong")&&this.emitHeartbeatEvent({name:"text_pong_sent",hop:this.resolveOutboundObsHop(),summary:"text pong sent",payload:{transport:"text",direction:"outbound"}}),!0)):"pong"===t&&(this.emitHeartbeatEvent({name:"text_pong_recv",hop:this.resolveInboundObsHop(),summary:"text pong recv",payload:{transport:"text",direction:"inbound"}}),!0)}handleHandshakeResponse(e){const t=e.frame;if(!t.ok){const n=t.error?.message??"handshake failed",s=Date.now()-e.connectStartedAt;return this.logger.error(`[${this.name}] handshake rejected: ${n}`),this.emitHandshakeEvent({name:"reject",severity:"error",summary:"handshake rejected",payload:{durationMs:s,gatewayErrorCode:t.error?.code,gatewayErrorMessage:n},error:t.error}),e.attempt.connectFailed||(e.attempt.connectFailed=!0,this.emitTransportEvent(e.connectionId,{name:"connect_fail",severity:"error",summary:"handshake rejected",payload:{durationMs:s,gatewayErrorCode:t.error?.code,gatewayErrorMessage:n},error:{code:"HANDSHAKE_REJECTED",message:n,gatewayError:t.error}})),void this.ws?.close(1008,"handshake rejected")}this.ready=!0,this.lastReadyAt=Date.now(),this.backoffMs=this.retry.baseMs,this.attempts=0,this.logger.info(`[${this.name}] handshake complete`),this.emitHandshakeEvent({name:"success",summary:"handshake complete",payload:{durationMs:Date.now()-e.connectStartedAt}}),this.emitTransportEvent(e.connectionId,{name:"connect_ok",severity:"info",payload:{durationMs:Date.now()-e.connectStartedAt}}),this.onReady?.()}queueConnect(){this.connectSent=!1,this.connectNonce=null,this.connectTimer&&clearTimeout(this.connectTimer),this.connectTimer=setTimeout(()=>{this.sendConnect("timer")},750)}sendConnect(e){if(this.connectSent||!this.ws||this.ws.readyState!==WebSocket.OPEN)return;this.connectSent=!0,this.connectTimer&&(clearTimeout(this.connectTimer),this.connectTimer=null);const t=this.buildConnect(this.connectNonce??void 0);try{const n=JSON.stringify(t);this.sendRaw(n)&&this.emitHandshakeEvent({name:"connect_sent",summary:"connect request sent",payload:{trigger:e,noncePresent:"string"==typeof this.connectNonce&&this.connectNonce.length>0}})}catch(e){this.logger.warn(`[${this.name}] connect send failed: ${String(e)}`)}}scheduleReconnect(e){if(this.closing)return;if(this.retry.maxAttempts>0&&this.attempts>=this.retry.maxAttempts)return this.logger.error(`[${this.name}] retry limit reached, giving up`),void this.emitTransportEvent(e,{name:"retry_exhausted",severity:"error",summary:"retry limit reached, giving up",payload:{attempt:this.attempts,maxAttempts:this.retry.maxAttempts}});const t=Math.min(this.backoffMs,this.retry.maxMs),n=this.attempts+1,s=Math.min(2*this.backoffMs,this.retry.maxMs);this.emitTransportEvent(e,{name:"reconnect_scheduled",severity:"info",payload:{reconnectDelayMs:t,attempt:n,nextBackoffMs:s}}),this.attempts=n,this.backoffMs=s,this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.reconnectTimer=setTimeout(()=>this.connect(),t),this.reconnectTimer.unref?.()}}