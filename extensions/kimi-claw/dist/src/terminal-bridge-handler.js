import{TerminalNotFoundError,TerminalClosedError,TerminalTimeoutError,TERMINAL_SESSION_STATES,TERMINAL_TIMEOUT_REASONS}from"./terminal-session-manager.js";import{isTerminalEnvelope,getTerminalPayloadAction}from"./terminal-bridge-protocol.js";import{TERMINAL_ERROR_CODES}from"./terminal-rpc.js";import{isPlainRecord as isRecord}from"./utils/json.js";import{asTrimmedNonEmptyString as asString}from"./utils/text.js";function readPositiveInteger(e){if("number"==typeof e&&Number.isInteger(e)&&!(e<=0))return e}function resolvePayloadFields(e){const t=e.content;return isRecord(t)?t:e}function buildEnvelope(e,t,r){return{type:"terminal",terminalId:e,_clientId:t,payload:r}}function snapshotToOpenedPayload(e){return{action:"opened",terminalId:e.terminalId,sessionId:e.sessionId,shell:e.shell,cwd:e.cwd,cols:e.cols,rows:e.rows,state:e.state,startedAt:e.startedAt,lastActiveAt:e.lastActiveAt}}function toErrorPayload(e,t){return{action:"error",code:e,message:t}}const DEFAULT_HEARTBEAT_TIMEOUT_MS=6e4;export class TerminalBridgeHandler{manager;sendBridgeMessage;logger;shell;heartbeatTimeoutMs;setTimer;clearTimer;terminalToClientId=new Map;heartbeatTimers=new Map;constructor(e){this.manager=e.manager,this.sendBridgeMessage=e.sendBridgeMessage,this.logger=e.logger,this.shell=e.shell,this.heartbeatTimeoutMs=readPositiveInteger(e.heartbeatTimeoutMs)??6e4,this.setTimer=e.setTimer??((e,t)=>setTimeout(e,t)),this.clearTimer=e.clearTimer??(e=>clearTimeout(e)),this.manager.addListeners({onOutput:e=>this.handleOutput(e),onExit:e=>this.handleExit(e),onStateChange:e=>this.handleStateChange(e)})}handleMessage(e){if(!isTerminalEnvelope(e))return!1;const t=e,{terminalId:r,_clientId:s,payload:i}=t,n=getTerminalPayloadAction(i);return this.terminalToClientId.set(r,s),"open"===n?(this.handleOpen(t),!0):"input"===n?(this.handleInput(t),!0):"resize"===n?(this.handleResize(t),!0):"close"===n?(this.handleClose(t),!0):"heartbeat"===n?(this.handleHeartbeat(t),!0):(this.sendError(t,-32601,`unknown terminal action: ${n??"missing"}`),!0)}sendError(e,t,r){this.sendBridgeMessage(buildEnvelope(e.terminalId,e._clientId,toErrorPayload(t,r)))}handleOpen(e){const{terminalId:t,_clientId:r,payload:s}=e,i=resolvePayloadFields(s);if(!this.shell.enabled)return void this.sendBridgeMessage(buildEnvelope(t,r,toErrorPayload(TERMINAL_ERROR_CODES.shellDisabled,"shell disabled")));if(this.manager.getSession(t))return void this.sendBridgeMessage(buildEnvelope(t,r,toErrorPayload(TERMINAL_ERROR_CODES.terminalClosed,"terminal already exists")));const n=asString(i.sessionId)??t,a=readPositiveInteger(i.cols),o=readPositiveInteger(i.rows);if(a&&o)if(this.evictOldestSessionsForQuota(t),this.listConcurrentSessions().length>=this.shell.maxConcurrentSessions)this.sendBridgeMessage(buildEnvelope(t,r,toErrorPayload(TERMINAL_ERROR_CODES.terminalQuotaExceeded,"terminal quota exceeded")));else try{const e=this.manager.openSession({sessionId:n,cols:a,rows:o,cwd:asString(i.cwd),shell:asString(i.shell),terminalId:t});this.refreshHeartbeatTimeout(t);const s=snapshotToOpenedPayload(e);this.sendBridgeMessage(buildEnvelope(t,r,s)),this.logger.info(`[terminal-bridge] sent opened terminalId=${t} state=${e.state}`)}catch(e){const s=e instanceof Error?e.message:String(e);this.logger.warn(`[terminal-bridge] open failed terminalId=${t}: ${s}`),this.sendBridgeMessage(buildEnvelope(t,r,toErrorPayload(-32e3,s)))}else this.sendBridgeMessage(buildEnvelope(t,r,toErrorPayload(-32602,"cols and rows must be positive integers")))}handleInput(e){const{terminalId:t,_clientId:r,payload:s}=e,i=s,n=resolvePayloadFields(i),a=asString(n.dataBase64)??asString(n.contentBase64);let o;if(a)try{o=Buffer.from(a,"base64")}catch{return void this.sendError(e,-32602,"invalid dataBase64")}else{const t="string"==typeof i.content?i.content:"string"==typeof n.content?n.content:void 0;if("string"!=typeof t)return void this.sendError(e,-32602,"dataBase64 or content required");o=Buffer.from(t,"utf8")}try{this.manager.writeToSession(t,o),this.refreshHeartbeatTimeout(t)}catch(e){this.sendTerminalErrorEnvelope(t,r,e)}}handleResize(e){const{terminalId:t,_clientId:r,payload:s}=e,i=resolvePayloadFields(s),n=readPositiveInteger(i.cols),a=readPositiveInteger(i.rows);if(n&&a)try{this.manager.resizeSession(t,n,a),this.refreshHeartbeatTimeout(t)}catch(e){this.sendTerminalErrorEnvelope(t,r,e)}else this.sendError(e,-32602,"cols and rows must be positive integers")}handleHeartbeat(e){const{terminalId:t,_clientId:r}=e;try{this.manager.touchSession(t),this.refreshHeartbeatTimeout(t)}catch(e){this.sendTerminalErrorEnvelope(t,r,e)}}handleClose(e){const{terminalId:t,_clientId:r}=e;this.clearHeartbeatTimeout(t);try{this.manager.closeSession(t)}catch(e){this.sendTerminalErrorEnvelope(t,r,e)}}sendTerminalErrorEnvelope(e,t,r){if(r instanceof TerminalNotFoundError)return void this.sendBridgeMessage(buildEnvelope(e,t,toErrorPayload(TERMINAL_ERROR_CODES.terminalNotFound,r.message)));if(r instanceof TerminalTimeoutError)return void this.sendBridgeMessage(buildEnvelope(e,t,toErrorPayload(TERMINAL_ERROR_CODES.terminalTimeout,r.message)));if(r instanceof TerminalClosedError)return void this.sendBridgeMessage(buildEnvelope(e,t,toErrorPayload(TERMINAL_ERROR_CODES.terminalClosed,r.message)));const s=r instanceof Error?r.message:String(r);this.sendBridgeMessage(buildEnvelope(e,t,toErrorPayload(-32e3,s)))}handleOutput(e){const t=this.terminalToClientId.get(e.terminalId);if(!t)return;const r={event:"stdout",dataBase64:e.data.toString("base64"),seq:e.seq};this.sendBridgeMessage(buildEnvelope(e.terminalId,t,r))}handleExit(e){this.clearHeartbeatTimeout(e.terminalId);const t=this.terminalToClientId.get(e.terminalId);if(!t)return void this.terminalToClientId.delete(e.terminalId);const r={event:"exit",code:e.code,signal:e.signal,...e.reason?{reason:e.reason}:{}};this.sendBridgeMessage(buildEnvelope(e.terminalId,t,r)),this.terminalToClientId.delete(e.terminalId)}handleStateChange(e){const t=this.terminalToClientId.get(e.terminalId);if(!t)return;const r={event:"state",from:e.from,to:e.to};this.sendBridgeMessage(buildEnvelope(e.terminalId,t,r))}listConcurrentSessions(){return this.manager.listSessions().filter(e=>e.state===TERMINAL_SESSION_STATES.opening||e.state===TERMINAL_SESSION_STATES.running)}evictOldestSessionsForQuota(e){const t=Math.max(1,this.shell.maxConcurrentSessions);let r=this.listConcurrentSessions().filter(t=>t.terminalId!==e);for(;r.length>=t;){const s=this.pickOldestSession(r);if(!s)return;this.logger.info(`[terminal-bridge] terminal quota exceeded limit=${t}; closing oldest terminalId=${s.terminalId} startedAt=${s.startedAt}`),this.clearHeartbeatTimeout(s.terminalId);try{this.manager.closeSession(s.terminalId,{reason:TERMINAL_TIMEOUT_REASONS.idle})}catch(e){const t=e instanceof Error?e.message:String(e);return void this.logger.warn(`[terminal-bridge] failed to close oldest terminalId=${s.terminalId}: ${t}`)}r=this.listConcurrentSessions().filter(t=>t.terminalId!==e)}}pickOldestSession(e){if(0!==e.length)return[...e].sort((e,t)=>e.startedAt!==t.startedAt?e.startedAt-t.startedAt:e.lastActiveAt!==t.lastActiveAt?e.lastActiveAt-t.lastActiveAt:e.terminalId.localeCompare(t.terminalId))[0]}refreshHeartbeatTimeout(e){this.clearHeartbeatTimeout(e);const t=this.setTimer(()=>{this.heartbeatTimers.delete(e),this.logger.warn(`[terminal-bridge] heartbeat timeout terminalId=${e} timeout_ms=${this.heartbeatTimeoutMs}`);try{this.manager.closeSession(e,{reason:TERMINAL_TIMEOUT_REASONS.idle})}catch(t){const r=t instanceof Error?t.message:String(t);this.logger.warn(`[terminal-bridge] failed to close heartbeat-timeout terminalId=${e}: ${r}`)}},this.heartbeatTimeoutMs);t.unref?.(),this.heartbeatTimers.set(e,t)}clearHeartbeatTimeout(e){const t=this.heartbeatTimers.get(e);t&&(this.heartbeatTimers.delete(e),this.clearTimer(t))}}