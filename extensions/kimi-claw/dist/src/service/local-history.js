import{existsSync,readFileSync}from"node:fs";import os from"node:os";import path from"node:path";import{stripTransportMetadata}from"../message-filter.js";import{isRecord}from"../utils/json.js";import{asTrimmedNonEmptyString as asString}from"../utils/text.js";const ACP_HISTORY_LIMIT=50,toHistoryText=e=>{if("string"==typeof e&&e.trim())return stripTransportMetadata(e.trim())||void 0;if(!Array.isArray(e))return;const s=[];for(const t of e){if(!isRecord(t))continue;if("text"!==asString(t.type))continue;const e=asString(t.text);e&&s.push(e)}return 0!==s.length&&stripTransportMetadata(s.join("\n"))||void 0};export const resolveOpenClawHome=()=>asString(process.env.OPENCLAW_HOME)||path.join(os.homedir(),".openclaw");export const replayHistoryFromLocalSessionFiles=e=>{const s=path.join(resolveOpenClawHome(),"agents",e.agentId,"sessions"),t=path.join(s,"sessions.json");if(!existsSync(t))return e.logger.debug?.(`[acp-history] sessions store missing path=${t}`),0;let r="";try{r=readFileSync(t,"utf-8")}catch(s){return e.logger.warn(`[acp-history] failed to read sessions store: ${String(s)}`),0}let o={};try{const e=JSON.parse(r);isRecord(e)&&(o=e)}catch(s){return e.logger.warn(`[acp-history] failed to parse sessions store: ${String(s)}`),0}const n=e.requestedSessionKey&&isRecord(o[e.requestedSessionKey])?o[e.requestedSessionKey]:void 0,i=(()=>{for(const[s,t]of Object.entries(o))if(isRecord(t)&&asString(t.sessionId)===e.sessionId)return{key:s,entry:t}})(),a=n??i?.entry,c=asString(a?.sessionFile)??path.join(s,`${e.sessionId}.jsonl`);if(!existsSync(c))return e.logger.debug?.(`[acp-history] session file missing path=${c}`),0;let d="";try{d=readFileSync(c,"utf-8")}catch(s){return e.logger.warn(`[acp-history] failed to read session file: ${String(s)}`),0}const p=[];for(const e of d.split(/\r?\n/)){const s=e.trim();if(!s)continue;let t;try{t=JSON.parse(s)}catch{continue}if(!isRecord(t)||"message"!==asString(t.type)||!isRecord(t.message))continue;const r=asString(t.message.role);if("user"!==r&&"assistant"!==r)continue;const o=toHistoryText(t.message.content);o&&p.push({role:r,text:o})}const g=p.slice(-50);if(0===g.length)return e.logger.debug?.(`[acp-history] no replayable user/assistant text in session file=${c}`),0;for(const s of g){const t="user"===s.role?{sessionUpdate:"user_message_chunk",content:{type:"text",text:s.text}}:{sessionUpdate:"agent_message_chunk",content:{type:"text",text:s.text}};e.send({jsonrpc:"2.0",method:"session/update",params:{sessionId:e.sessionId,update:t,...e.requestId?{_meta:{requestId:e.requestId}}:{}}})}return e.logger.info(`[acp-history] replayed ${g.length} updates sessionId=${e.sessionId} key=${e.requestedSessionKey??i?.key??"unknown"}`),g.length};export const readLatestAssistantTextFromLocalSessionFiles=e=>{const s=[],t={info:()=>{},warn:s=>e.logger.warn(s),error:s=>e.logger.error(s),debug:()=>{}};if(replayHistoryFromLocalSessionFiles({agentId:e.agentId,sessionId:e.sessionId,requestedSessionKey:e.requestedSessionKey,logger:t,send:e=>{if(!isRecord(e)||"session/update"!==asString(e.method)||!isRecord(e.params))return;const t=e.params;if(!isRecord(t.update))return;const r=t.update;if("agent_message_chunk"!==asString(r.sessionUpdate)||!isRecord(r.content))return;const o=asString(r.content.text);o&&s.push(o)}}),0!==s.length)return s[s.length-1]};